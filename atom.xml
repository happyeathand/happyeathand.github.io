<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://happyeathand.github.io</id>
    <title>闲鱼小站</title>
    <updated>2022-03-31T02:58:25.273Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://happyeathand.github.io"/>
    <link rel="self" href="https://happyeathand.github.io/atom.xml"/>
    <subtitle> 切忌好高骛远</subtitle>
    <logo>https://happyeathand.github.io/images/avatar.png</logo>
    <icon>https://happyeathand.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 闲鱼小站</rights>
    <entry>
        <title type="html"><![CDATA[骗分导论（转载）]]></title>
        <id>https://happyeathand.github.io/post/pian-fen-dao-lun-zhuan-zai/</id>
        <link href="https://happyeathand.github.io/post/pian-fen-dao-lun-zhuan-zai/">
        </link>
        <updated>2022-03-30T09:05:11.000Z</updated>
        <content type="html"><![CDATA[<p>蒟 蒻 的 宝 书</p>
<p>目录 第1章 绪论</p>
<p>第2章 从无解出发</p>
<p>2.1 无解情况</p>
<p>2.2 样例——白送的分数</p>
<p>第3章 “艰苦朴素永不忘”</p>
<p>3.1 模拟</p>
<p>3.2 万能钥匙——DFS</p>
<p>第4章 骗分的关键——猜想</p>
<p>4.1 听天由命</p>
<p>4.2 猜测答案</p>
<p>4.3 寻找规律</p>
<p>4.4 小数据杀手——打表</p>
<p>第5章 做贪心的人</p>
<p>5.1 贪心的算法</p>
<p>5.2 贪心地得分</p>
<p>第6章 C++的福利</p>
<p>6.1 快速排序</p>
<p>6.2 “如意金箍棒”</p>
<p>第7章 “宁为玉碎，不为瓦全”</p>
<p>第8章 实战演练</p>
<p>第9章 结语</p>
<p>第1章 绪论</p>
<p>在Oier中，有一句话广为流传：</p>
<p>任何蒟蒻必须经过大量的刷题练习才能成为大牛乃至于神牛。</p>
<p>这就是著名的lzn定理。然而，我们这些蒟蒻们，没有经过那么多历练，却要和大牛们同场竞技，我们该怎么以弱胜强呢？答案就是：</p>
<p>骗分 那么，骗分是什么呢？骗分就是用简单的程序（比标准算法简单很多，保证蒟蒻能轻松搞定的程序），尽可能多得骗取分数。</p>
<p>让我们走进这本《新版骗分导论》，来学习骗分的技巧，来挑战神牛吧！</p>
<p>第2章 从无解出发</p>
<p>2.1 无解情况</p>
<p>在很多题目中都有这句话：“若无解，请输出-1.”</p>
<p>看到这句话时，骗分的蒟蒻们就欣喜若狂，因为——数据中必定会有无解的</p>
<p>情况！那么，只要打出下面这个程序：</p>
<p>printf(“-1”);</p>
<p>就能得到10分，甚至20分，30分！</p>
<p>举个例子：</p>
<p>NOIP2012第4题，文化之旅</p>
<p>题目描述 Description</p>
<p>有一位使者要游历各国，他每到一个国家，都能学到一种文化，但他不愿意学习任何一种文化超过一次（即如果他学习了某种文化，则他就不能到达其他有这种文化的国家）。不同的国家可能有相同的文化。不同文化的国家对其他文化的看法不同，有些文化会排斥外来文化（即如果他学习了某种文化，则他不能到达排斥这种文化的其他国家）。</p>
<p>现给定各个国家间的地理关系，各个国家的文化，每种文化对其他文化的看法，以及这位使者游历的起点和终点（在起点和终点也会学习当地的文化），国家间的道路距离，试求从起点到终点最少需走多少路。</p>
<p>输入描述 Input Description</p>
<p>第一行为五个整数N，K，M，S，T，每两个整数之间用一个空格隔开，依次代表国家个数（国家编号为1到N），文化种数（文化编号为1到K），道路的条数，以及起点和终点的编号（保证S不等于T）；</p>
<p>第二行为N个整数，每两个整数之间用一个空格隔开，其中第i个数Ci，表示国家i的文化为Ci。</p>
<p>接下来的K行，每行K个整数，每两个整数之间用一个空格隔开，记第i行的第j个数为aij，aij= 1表示文化i排斥外来文化j（i等于j时表示排斥相同文化的外来人），aij= 0表示不排斥（注意i排斥j并不保证j一定也排斥i）。</p>
<p>接下来的M行，每行三个整数u，v，d，每两个整数之间用一个空格隔开，表示国家u与国家v有一条距离为d的可双向通行的道路（保证u不等于v，两个国家之间可能有多条道路）。</p>
<p>输出描述 Output Description</p>
<p>输出只有一行，一个整数，表示使者从起点国家到达终点国家最少需要走的距离数（如果无解则输出-1）。</p>
<p>样例输入 Sample Input</p>
<p>输入样例1</p>
<p>2 2 1 1 2</p>
<p>1 2 0 1 1 0 1 2 10 输入样例2</p>
<p>2 2 1 1 2</p>
<p>1 2 0 1 0 0 1 2 10 样例输出 Sample Output</p>
<p>输出样例1</p>
<p>-1 输出样例2</p>
<p>10 数据范围及提示 Data Size &amp; Hint</p>
<p>【输入输出样例1说明】</p>
<p>由于到国家2必须要经过国家1，而国家2的文明却排斥国家1的文明，所以不可能到达国家2。</p>
<p>【输入输出样例2说明】</p>
<p>路线为1 -&gt; 2。</p>
<p>【数据范围】</p>
<p>对于20%的数据，有2≤N≤8，K≤5；</p>
<p>对于30%的数据，有2≤N≤10，K≤5；</p>
<p>对于50%的数据，有2≤N≤20，K≤8；</p>
<p>对于70%的数据，有2≤N≤100，K≤10；</p>
<p>对于100%的数据，有2≤N≤100，1≤K≤100，1≤M≤N2，1≤ki≤K，1≤u,v≤N，1≤d≤1000，S≠T，1 ≤S, T≤N。</p>
<p>这道题看起来很复杂，但其中有振奋人心的一句话“输出-1”，我考试时就高兴坏了（当时我才初一，水平太烂），随手打了个printf(“-1”);,得10分。</p>
<p>2.2 样例——白送的分数</p>
<p>每道题目的后面，都有一组“样例输入”和“样例输出”。它们的价值极大，不仅能初步帮你检验程序的对错（特别坑的样例除外），而且，如果你不会做这道题（这种情况蒟蒻们已经司空见惯了），你就可以直接输出样例！</p>
<p>例如美国的USACO，它的题目有一个规则，就是第一组数据必须是样例。那么，只要你输出所有的样例，你就能得到100分（满分1000）！这是相当可观的分数了。</p>
<p>现在，你已经掌握了最基础的骗分技巧。只要你会基本的输入输出语句，你就能实现这些骗分方法。那么，如果你有一定的基础，请看下一章——我将教你怎样用简单方法骗取部分分数。</p>
<p>第3章 “艰苦朴素永不忘”</p>
<p>本章的标题来源于《学习雷锋好榜样》的一句歌词，但我不是想教导你们学习雷锋精神，而是学习骗分！</p>
<p>看到“朴素”两个字了吗？它们代表了一类算法，主要有模拟和DFS。下面我就来介绍它们在骗分中的应用。</p>
<p>3.1 模拟</p>
<p>所谓模拟，就是用计算机程序来模拟实际的事件。例如NOIP2012的“寻宝”，就是写一个程序来模拟小明上藏宝塔的动作。</p>
<p>较繁的模拟就不叫骗分了，我这里也不讨论这个问题。</p>
<p>模拟主要可以应用在骗高级数据结构题上的分，例如线段树。下面举一个例子来说明一下。</p>
<p>排 队(USACO 2007 January Silver)</p>
<p>【问题描述】</p>
<p>每天，农夫约翰的N（1≤N≤50000）头奶牛总是按同一顺序排好队，有一天，约翰决定让一些牛玩一场飞盘游戏（Ultimate Frisbee），他决定在队列里选择一群位置连续的奶牛进行比赛，为了避免比赛结果过于悬殊，要求挑出的奶牛身高不要相差太大。</p>
<p>约翰准备了Q（1≤Q≤200000）组奶牛选择，并告诉你所有奶牛的身高Hi（1≤ Hi ≤106）。他想知道每组里最高的奶牛和最矮的奶牛身高差是多少。</p>
<p>注意：在最大的数据上，输入输出将占据大部分时间。</p>
<p>【输入】</p>
<p>第一行，两个用空格隔开的整数N和Q。</p>
<p>第2到第N+1行，每行一个整数，第i+1行表示第i头奶牛的身高Hi</p>
<p>第N+2到第N+Q+1行，每行两个用空格隔开的整数A和B，表示选择从A到B的所有牛（1 ≤ A ≤ B ≤ N）</p>
<p>【输出】</p>
<p>共Q行，每行一个整数，代表每个询问的答案。</p>
<p>输入样例 输出样例</p>
<p>6 3 1 7 3 4 2 5 1 5 4 6 2 2 6</p>
<p>3 0</p>
<p>对于这个例子，大牛们可以写个线段树，而我们蒟蒻，就模拟吧。</p>
<p>附模拟程序：</p>
<p>for(int i=1;i&lt;=q;i++){<br>
scanf(“%d%d”,&amp;a,&amp;b);<br>
int min=INT_MAX,max=INT_MIN;<br>
for(int i=a;i&lt;=b;i++){<br>
if(h[i]&lt;min)min=h[i];<br>
if(h[i]&gt;max)max=h[i];<br>
}<br>
printf(“%d\n”,max-min);<br>
}<br>
程序简洁明了，并且能高效骗分。本程序得50分。 3.2 万能钥匙——DFS</p>
<p>DFS是图论中的重要算法，但我们看来，图论神马的都是浮云，关键就是如何骗分。下面引出本书的第2条定理：</p>
<p>DFS是万能的。</p>
<p>这对于你的骗分是至关重要的。比如说，一些动态规划题，可以DFS；数学题，可以DFS；剪枝的题，更能DFS。下面以一道省选题为例，解释一下DFS骗分。</p>
<p>例题：NOIP2003，采药</p>
<p>题目描述 Description</p>
<p>辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”</p>
<p>如果你是辰辰，你能完成这个任务吗？</p>
<p>输入描述 Input Description</p>
<p>输入第一行有两个整数T（1&lt;=T&lt;=1000）和M（1&lt;=M&lt;=100），用一个空格隔开，T代表总共能够用来采药的时间，M代表山洞里的草药的数目。接下来的M行每行包括两个在1到100之间（包括1和100）的整数，分别表示采摘某株草药的时间和这株草药的价值。</p>
<p>输出描述 Output Description</p>
<p>输出包括一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。</p>
<p>样例输入 Sample Input</p>
<p>70 3 71 100 69 1 1 2 样例输出 Sample Output</p>
<p>3 数据范围及提示 Data Size &amp; Hint</p>
<p>对于30%的数据，M&lt;=10；</p>
<p>对于全部的数据，M&lt;=100。</p>
<p>这题的方法很简单。我们瞄准20%的数据来做，可以用DFS枚举方案，然后模拟计算出最优解。附一个大致的代码：</p>
<p>void DFS(int d,int c){<br>
if(d==n){if(c&gt;ans)ans=c; return;}<br>
DFS(d+1,c+w[i]);<br>
DFS(d+1,c);<br>
}<br>
第4章 骗分的关键——猜想 4.1 听天由命</p>
<p>如果你觉得你的人品很好，可以试试这一招——输出随机数。</p>
<p>先看一下代码：</p>
<p>#include&lt;stdlib.h&gt;<br>
#include&lt;time.h&gt;<br>
//以上两个头文件必须加<br>
srand(time(NULL));<br>
//输出随机数前执行此语句<br>
printf(“%d”,rand()%X);<br>
//输出一个0~X-1的随机整数。<br>
这种方法适用于输出一个整数（或判断是否）的题目中，答案的范围越小越好。让老天决定你的得分吧。 据说，在NOIP2013中，有人最后一题不会，愤然打了个随机数，结果得了70分啊!!</p>
<p>4.2 猜测答案</p>
<p>有些时候，问题的答案可能很有特点：对于大多数情况，答案是一样的。这时，骗分就该出手了。你需要做的，就是发掘出这个答案，然后直接输出。</p>
<p>有时，你需要运用第3章中学到的知识，先写出朴素算法，然后造一些数据，可能就会发现规律。</p>
<p>例如，本班月赛中有一道题：</p>
<p>炸毁计划</p>
<p>【问题描述】</p>
<p>皇军侵占了通往招远的黄金要道。为了保护渤海通道的安全，使得黄金能够顺利地运送到敌后战略总指挥地延安，从而购买战需武器，所以我们要通过你的程序确定这条战略走廊是否安全。</p>
<p>已知我们有N座小岛，只有使得每一个小岛都能与其他任意一个小岛联通才能保证走廊的安全。每个小岛之间只能通过若干双向联通的桥保持联系，已知有M座桥(Ai,Bi)表示第i座桥连接了Ai与Bi这两座城市。</p>
<p>现在，敌人的炸药只能炸毁其中一座桥，请问在仅仅炸毁这一座桥的情况下，能否保证所有岛屿安全，都能联通起来。</p>
<p>现在给出Q个询问Ci，其中Ci表示桥梁编号，桥梁的编号按照输入顺序编号。每个询问表示在仅仅炸毁第Ci座桥的情况下能否保证所有岛屿安全。如果可以，在输出文件当中，对应输入顺序输出yes，否则输出no（输出为半角英文单词，区分大小写，默认为小写，不含任何小写符号，每行输出一个空格，忽略文末空格）。</p>
<p>【输入格式】</p>
<p>第一行 三个整数N，M，Q，分别表示岛屿的个数，桥梁的个数和询问的个数。</p>
<p>第二行到第M+1行 每行两个整数。第i+1行有两个整数Ai Bi表示这个桥梁的属性。</p>
<p>第M+2行 有Q个整数Ci表示查询。</p>
<p>【输出格式】</p>
<p>Q行，表示查询结果。</p>
<p>【样例】</p>
<p>destroy.in destroy.out</p>
<p>2 1 1 1 2 1 no</p>
<p>【样例范围】</p>
<p>对于80%的数据，N≤100。</p>
<p>对于100%的数据，N≤1000，N,Q≤M≤2000 。</p>
<p>你发现问题了吗？那么多座桥，炸一座就破坏岛屿的联系，可能性微乎其微（除非特别设计数据）。那么，我们的骗分策略就出来了：对于所有询问，输出yes.果然，此算法效果不错，得80分。</p>
<p>现在知道猜测答案的厉害了吧？</p>
<p>4.3 寻找规律</p>
<p>首先声明：本节讲的规律不是正当的算法规律，而是数据的特点。</p>
<p>某些题目会给你很多样例，你就可以观察他们的特点了。有时，数据中的某一个（或几个）数，能通过简单的关系直接算出答案。</p>
<p>只要你找到了规律，在很多情况下你都能得到可观的分数。</p>
<p>这样的题目大多出现在NOI或更高等级的比赛中，本人蒟蒻一个，就不举例了。传说某人去省选时专门琢磨数据的规律，结果有一题得了30分。</p>
<p>4.4 小数据杀手——打表</p>
<p>我认识一个人，他在某老师家上C语言家教，老师每讲一题，他都喊一句：“打表行吗？”</p>
<p>他真的是打表的忠实粉丝。表虽然不能乱打，但还是很有用的。</p>
<p>先看一个例子：NOIP2003 栈</p>
<p>题目描述 Description</p>
<p>栈是计算机中经典的数据结构，简单的说，栈就是限制在一端进行插入删除操作的线性表。</p>
<p>栈有两种最重要的操作，即pop（从栈顶弹出一个元素）和push（将一个元素进栈）。</p>
<p>栈的重要性不言自明，任何一门数据结构的课程都会介绍栈。宁宁同学在复习栈的基本概念时，想到了一个书上没有讲过的问题，而他自己无法给出答案，所以需要你的帮忙</p>
<p>宁宁考虑的是这样一个问题：一个操作数序列，从1，2，一直到n（图示为1到3的情况），栈A的深度大于n。</p>
<p>现在可以进行两种操作，</p>
<p>1.将一个数，从操作数序列的头端移到栈的头端（对应数据结构栈的push操作）</p>
<p>将一个数，从栈的头端移到输出序列的尾端（对应数据结构栈的pop操作）<br>
使用这两种操作，由一个操作数序列就可以得到一系列的输出序列，下图所示为由1 2 3生成序列2 3 1的过程。（原始状态如上图所示） 。</p>
<p>你的程序将对给定的n，计算并输出由操作数序列1，2，…，n经过操作可能得到的输出序列的总数。</p>
<p>输入描述 Input Description</p>
<p>输入文件只含一个整数n（1≤n≤18）</p>
<p>输出描述 Output Description</p>
<p>输出文件只有一行，即可能输出序列的总数目</p>
<p>样例输入 Sample Input</p>
<p>3 样例输出 Sample Output</p>
<p>5</p>
<p>这题看似复杂，但数据范围太小，N&lt;=18。所以，骗分程序就好写了：</p>
<p>int a[18]={1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440,9694845,35357670,129644790,477638700};</p>
<p>scanf(“%d”,&amp;n):</p>
<p>printf(“%d”,ans[n-1]);</p>
<p>测试结果不言而喻，AC了。</p>
<p>学完这一章，你已基本掌握了骗分技巧。下面的内容涉及一点算法知识，难度有所增加。蒟蒻中的蒟蒻可以止步于此了。</p>
<p>第5章 做贪心的人</p>
<p>5.1 贪心的算法</p>
<p>给你一堆纸币，让你挑一张，相信你一定会挑面值最大的。其实，这就是贪心算法。</p>
<p>贪心算法是个复杂的问题，但你不用管那么多。我们只关心骗分。给你一个问题，让你从一些东西中选出一些，你就可以使用贪心的方法，尽量挑好的。</p>
<p>举个例子：这是我们的市队选拔的一道题。</p>
<p>有趣的问题<br>
【问题描述】</p>
<p>2013 年的NOIP 结束后， Smart 发现自己又被题目碾压了，心里非常地不爽，于是</p>
<p>暗下决心疯狂地刷数学题目，做到天昏地暗、废寝忘食，准备在今年的中考中大展身手。</p>
<p>有一天，他在做题时发现了一个有趣的问题：</p>
<p>给定n 个二元组(ai, bi) i)，记函数：</p>
<p>y=100*sigma(ai)/sigma(bi);</p>
<p>将函数y 的值四舍五入取整。</p>
<p>现将n 个二元组去掉其中的k 个计算一个新的y 值（也四舍五入取整），均能满足：y &lt;= z ，求出最小的z值。Smart 想让你帮他一起找出最小的z值。</p>
<p>【输入格式】</p>
<p>输入包含多组测试数据。每组测试数据第一行两个整数：n和k；第二行为n 个数：</p>
<p>a1 a2 …… an；第三行为；n 个数： b1 b2 …… bn。</p>
<p>输入数据当n、k 均为0 时结束。</p>
<p>【输出格式】</p>
<p>对于每组测试数据输出一行，即找出的最小的冘值。</p>
<p>注意：为避免精度四舍五入出现误差，测试点保证每个函数值与最终结果的差值至</p>
<p>少为0.001 。</p>
<p>【样例】</p>
<p>math.in</p>
<p>3 1 5 0 1 5 1 6 4 2 1 2 7 9</p>
<p>5 6 7 9</p>
<p>0 0 math. out</p>
<p>83 100 【数据范围】</p>
<p>对于40% 的数据： n≤20；</p>
<p>对于70% 的数据： n≤1000；</p>
<p>对于100% 的数据： n≤10000，ai,bi 都在int 范围内。</p>
<p>这题让人望而生畏，但我们有贪心的手段。每个二元组的a值是乘到答案中的，所以a越大越好，那么只要选择出最小的k个去掉即可。代码就不写了，因为这个设计到下一章的内容：排序。</p>
<p>此代码得20分。</p>
<p>5.2 贪心地得分</p>
<p>我们已经学了很多骗分方法，但他们中的大多效率并不高，一般能骗10~20分。这不能满足我们的贪心。</p>
<p>然而，我们可以合成骗分的程序。举个最简单的例子，有些含有无解情况的题目，它们同样有样例。我们可以写这个程序</p>
<p>if(是样例)printf(样例);</p>
<p>else printf(“-1”);</p>
<p>这样也许能变10分为20分，甚至更多。</p>
<p>当然，合并骗分方法时要注意，不要重复骗同一种情况，或漏考虑一些情况。</p>
<p>大量能骗分的问题都能用此法，大家可以试试用新方法骗2.1中的例子“文化之旅”。</p>
<p>第6章 C++的福利</p>
<p>（请P党们跳过本章，这不是你们的福利）</p>
<p>在C++中，有一个好东西，名唤STL，被万千Oier们所崇拜，所喜爱。下面让我们走进STL。</p>
<p>6.1 快速排序</p>
<p>快速排序是一个经典算法，也是C++党的经典福利。他们有这样的代码：</p>
<p>#include<algorithm>//这是必须的</p>
<p>sort(A,A+n);//对一个下标从0开始存储，长度为n的数组升序排序<br>
就这么简单，完成了P党一大堆代码干的事情。</p>
<p>6.2 “如意金箍棒”</p>
<p>C++里有一种东西，叫vector容器。它好比如意金箍棒，可以随着元素的数量而改变大小。它其实就是数组，却比数组强得多。</p>
<p>下面看看它的几种操作：</p>
<pre><code>vector&lt;int&gt; V;//定义
</code></pre>
<p>V.push_back(x);//末尾增加一个元素x<br>
V.pop_back();//末尾删除一个元素<br>
V.size();//返回容器中的元素个数<br>
它同样可以使用下标访问。（从0开始） 第7章 “宁为玉碎，不为瓦全”</p>
<p>至此，我已介绍完了我所知的骗分方法。如果上面的方法都不奏效，我也无能为力。但是，我还有最后一招——</p>
<p>有句古话说：“宁为玉碎，不为瓦全”。我们蒟蒻也应有这样的精神。骗不到分，就报复一下，卡评测以泄愤吧！</p>
<p>卡评测主要有两种方法：一是死循环，故意超时；二是进入终端，卡住编译器。</p>
<p>先介绍下第一种。代码很简单，请看：</p>
<p>while(1);</p>
<p>就是这短短一句话，就能卡住评测机长达10s，20s，甚至更多！对于测试点多、时限长的题目，这是个不错的方法。</p>
<p>第二种方法也很简单，但危害性较大，建议不要在重要比赛中使用，否则可能让你追悔莫及。它就是：</p>
<p>include<con> （windows系统中使用）<br>
或 #include&lt;/dev/console&gt; （Linux系统中使用）</p>
<p>它非常强大，可以卡住评测系统，使其永远停止不了编译你的程序。唯一的解除方法是，工作人员强行关机，重启，重测。当然，我不保证他们不会气愤地把你的成绩变成0分。请慎用此方法。</p>
<p>第8章 实战演练</p>
<p>下面我们来做一些习题，练习骗分技巧。</p>
<p>我们来一起分析一下NOIP2013普及组的试题吧。</p>
<p>记数问题（NOIP普及组2013第一题）</p>
<p>(count.cpp/c/pas)</p>
<p>描述 试计算在区间 1 到 n 的所有整数中,数字 x(0 ≤ x ≤ 9)共出现了多少次?例如,在 1 到 11 中,即在 1、2、3、4、5、6、7、8、9、10、11 中,数字 1 出现了 4 次。</p>
<p>【输入】</p>
<p>输入文件名为 count.in。</p>
<p>输入共 1 行，包含 2 个整数 n、x，之间用一个空格隔开</p>
<p>【输出】</p>
<p>输出文件名为 count.out。</p>
<p>输出共 1 行，包含一个整数，表示 x 出现的次数。</p>
<p>【输入输出样例】</p>
<p>count.in count.out</p>
<p>11 1 4 限制 每个测试点1s。</p>
<p>【数据说明】</p>
<p>对于 100%的数据，1≤ n ≤ 1,000,000，0 ≤ x ≤ 9。</p>
<p>表达式求值（noip2013普及组第二题）</p>
<p>(expr.cpp/c/pas)</p>
<p>描述 给定一个只包含加法和乘法的算术表达式,请你编程计算表达式的值。</p>
<p>【输入】</p>
<p>输入文件为 expr.in。</p>
<p>输入仅有一行，为需要你计算的表达式，表达式中只包含数字、加法运算符“+”和乘 ，且没有括号，所有参与运算的数字均为 0 到 231-1 之间的整数。输入数据保 法运算符“*”</p>
<p>证这一行只有 0~ 9、+、*这 12 种字符。</p>
<p>【输出】</p>
<p>输出文件名为 expr.out。</p>
<p>输出只有一行，包含一个整数，表示这个表达式的值。注意：当答案长度多于 4 位时，</p>
<p>请只输出最后 4 位，前导 0 不输出。</p>
<p>【输入输出样例 1】</p>
<p>expr.in expr.out</p>
<p>1+1*3+4 8</p>
<p>【输入输出样例 2】</p>
<p>expr.in expr.out</p>
<p>1+1234567890*1 7891</p>
<p>【输入输出样例 3】</p>
<p>expr.in expr.out</p>
<p>1+1000000003*1 4</p>
<p>【输入输出样例说明】</p>
<p>样例 1 计算的结果为 8，直接输出 8。</p>
<p>样例 2 计算的结果为 1234567891，输出后 4 位，即 7891。</p>
<p>样例 3 计算的结果为 1000000004，输出后 4 位，即 4。</p>
<p>【数据范围】</p>
<p>对于 30%的数据，0≤表达式中加法运算符和乘法运算符的总数≤100；</p>
<p>对于 80%的数据，0≤表达式中加法运算符和乘法运算符的总数≤1000；</p>
<p>对于 100%的数据，0≤表达式中加法运算符和乘法运算符的总数≤100000。</p>
<p>小朋友的数字（noip2013普及组第三题）(number.cpp/c/pas)</p>
<p>描述 有 n 个小朋友排成一列。每个小朋友手上都有一个数字,这个数字可正可负。规定每个小朋友的特征值等于排在他前面(包括他本人)的小朋友中连续若干个(最少有一个)小朋友手上的数字之和的最大值。 作为这些小朋友的老师,你需要给每个小朋友一个分数,分数是这样规定的:第一个小朋友的分数是他的特征值,其它小朋友的分数为排在他前面的所有小朋友中(不包括他本人),小朋友分数加上其特征值的最大值。</p>
<p>请计算所有小朋友分数的最大值,输出时保持最大值的符号,将其绝对值对 p 取模后输出。</p>
<p>格式 【输入】</p>
<p>输入文件为 number.in。</p>
<p>第一行包含两个正整数 n、p，之间用一个空格隔开。</p>
<p>第二行包含 n 个数，每两个整数之间用一个空格隔开，表示每个小朋友手上的数字。</p>
<p>【输出】</p>
<p>输出文件名为 number.out。</p>
<p>输出只有一行，包含一个整数，表示最大分数对 p 取模的结果。</p>
<p>【输入输出样例 1】</p>
<p>number.in number.out</p>
<p>5 997 21</p>
<p>1 2 3 4 5</p>
<p>【输入输出样例说明】</p>
<p>小朋友的特征值分别为 1、3、6、10、15，分数分别为 1、2、5、11、21，最大值 21</p>
<p>对 997 的模是 21。</p>
<p>【输入输出样例 2】</p>
<p>第2/4页</p>
<p>number.in number.out</p>
<p>5 7 -1 -1 -1 -1 -1 -1</p>
<p>【输入输出样例说明】</p>
<p>小朋友的特征值分别为-1、-1、-1、-1、-1，分数分别为-1、-2、-2、-2、-2，最大值 -1 对 7 的模为-1，输出-1。</p>
<p>【数据范围】</p>
<p>对于 50%的数据，1 ≤ n ≤ 1,000，1 ≤ p ≤ 1,000所有数字的绝对值不超过 1000；</p>
<p>99 对于 100%的数据，1 ≤ n ≤ 1,000,000， 1≤ p ≤ 10， 其他数字的绝对值均不超过 10。</p>
<p>车站分级（NOIP普及组2013第四题）(level.cpp/c/pas)</p>
<p>描述 一条单向的铁路线上,依次有编号为 1, 2, ..., n 的 n 个火车站。每个火车站都有一个级别,最低为 1 级。现有若干趟车次在这条线路上行驶,每一趟都满足如下要求:如果这趟车次停靠了火车站 x,则始发站、终点站之间所有级别大于等于火车站 x 的都必须停靠。</p>
<p>(注意:起始站和终点站自然也算作事先已知需要停靠的站点)</p>
<p>例如,下表是 5 趟车次的运行情况。其中,前 4 趟车次均满足要求,而第 5 趟车次由于停靠了 3 号火车站(2 级)却未停靠途经的 6 号火车站(亦为 2 级)而不满足要求。</p>
<p>现有 m 趟车次的运行情况（全部满足要求） ，试推算这 n 个火车站至少分为几个不同的 级别。</p>
<p>【输入】</p>
<p>输入文件为 level.in。</p>
<p>第一行包含 2 个正整数 n, m，用一个空格隔开。</p>
<p>第 i + 1 行（1 ≤ i ≤ m）中，首先是一个正整数 si（2 ≤ si ≤ n），表示第 i 趟车次有 si 个停</p>
<p>靠站；接下来有 si 个正整数，表示所有停靠站的编号，从小到大排列。每两个数之间用一个 空格隔开。输入保证所有的车次都满足要求。</p>
<p>【输出】</p>
<p>输出文件为 level.out。</p>
<p>输出只有一行，包含一个正整数，即 n 个火车站最少划分的级别数。</p>
<p>第3/4页</p>
<p>【输入输出样例】</p>
<p>【数据范围】</p>
<p>对于 20%的数据，1 ≤ n, m ≤ 10； 对于 50%的数据，1 ≤ n, m ≤ 100； 对于 100%的数据，1 ≤ n, m ≤ 1000。</p>
<p>第1题，太弱了，不用骗，得100分。</p>
<p>第2题，数据很大，但是可以直接输入一个数，输出它mod 10000的值。得10分。</p>
<p>第3题，是一道非常基础的DP，但对于不知DP为何物的蒟蒻来说，就使用暴力算法（即DFS）。得20分。</p>
<p>第4题，我们可以寻找一下数据的规律，你会发现，在所有样例中，M值即为答案。所以直接输出M，得10分。</p>
<p>这样下来，一共得140分，比一等分数线还高20分（弱省）！你的信心一定会得到鼓舞的。这就是骗分的神奇。</p>
<p>第9章 结语</p>
<p>骗分是蒟蒻的有力武器，可以在比赛中骗得大量分数。相信大家在这本书中收获了很多，希望本书能帮助你多得一些分。</p>
<p>但是，最后我还是要说一句：</p>
<p>不骗分，是骗分的最高境界。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法常用]]></title>
        <id>https://happyeathand.github.io/post/suan-fa-chang-yong/</id>
        <link href="https://happyeathand.github.io/post/suan-fa-chang-yong/">
        </link>
        <updated>2022-03-30T09:01:39.000Z</updated>
        <content type="html"><![CDATA[<p>常用问题</p>
<ol>
<li>时间的计算，可以转换成int类型，无论是小时分秒还是年月日，同理</li>
<li>闰年的计算，闰年即可以被4整除的同时不可以被100整除，或者可以被400整除</li>
</ol>
<p>库函数的问题</p>
<ol>
<li>bool类型变量要定义头文件&lt;stdbool.h&gt;,如果自己的话不如定义int型的函数。如果是题目要求就没办法了</li>
<li>代码结尾一定要记得加return 0。</li>
<li>Int型最大能存21亿多点，准确来说是-2147483647~+2147483647<br>
而long long int可以存-9223372036854775808～+9223372036854775807，而且长长整型的输入和输出前面都要加一个ll，譬如scanf(“%lld”,&amp;a),printf(“%lld”,a)。<br>
4． 输出的补齐，补足两位用0补齐这么写：printf(“%02d”,a)<br>
数论</li>
<li>计算最大公约数的函数<br>
int gcd(int x,int b)//计算的是两个参数的最大公约数<br>
{<br>
if(b==0)return x;<br>
else return gcd(b,x%b);<br>
}<br>
最后的返回值就是最大公约数了，叫做欧几里得算法（辗转相除法）</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[过去的时光过去的人]]></title>
        <id>https://happyeathand.github.io/post/guo-qu-de-shi-guang-guo-qu-de-ren/</id>
        <link href="https://happyeathand.github.io/post/guo-qu-de-shi-guang-guo-qu-de-ren/">
        </link>
        <updated>2022-03-22T15:16:10.000Z</updated>
        <content type="html"><![CDATA[<p>最近几天不知为何，感触颇多，莫不是我也伤春悲秋了，大概还是太闲了。<br>
偶然翻到钟老师过去的文章，不禁开始回忆以前的事，以前的人，小时候写作文总爱把时间啊，人生啊比作火车，讲着珍惜什么窗外的风景，再者无法回头种种，可待这火车真的开出去了，就像再隆隆声中打了个盹，猛地一震，反应过来时已是二十余载......<br>
喘息间已是满眼遗憾，其中甚者更是在十三五岁时，若能再多一些勇气，别再和人交谈相处时畏手畏脚，若能再少一些叛逆，别再对老师和父母恶语相向，若再多一些成熟，多想想未来，哪怕课本枯燥，哪怕学习路上那么多坎坷，若是，若是.......<br>
可时光好似真的不能重来，眼下又活出了个一片狼藉，自己的生活和未来都是空白一片。可是，可是，二十岁的今天又何尝不是二十五岁，三十岁，四十岁的昨天呢，那样不是重获新生了吗，人生又能有几个二十年，奥里给，拒绝emo，奋斗在当下嘛</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ACwing1205. 买不到的数目]]></title>
        <id>https://happyeathand.github.io/post/acwing1205-mai-bu-dao-de-shu-mu/</id>
        <link href="https://happyeathand.github.io/post/acwing1205-mai-bu-dao-de-shu-mu/">
        </link>
        <updated>2022-03-12T02:30:33.000Z</updated>
        <content type="html"><![CDATA[<p>小明开了一家糖果店。</p>
<p>他别出心裁：把水果糖包成4颗一包和7颗一包的两种。</p>
<p>糖果不能拆包卖。</p>
<p>小朋友来买糖的时候，他就用这两种包装来组合。</p>
<p>当然有些糖果数目是无法组合出来的，比如要买 10 颗糖。</p>
<p>你可以用计算机测试一下，在这种包装情况下，最大不能买到的数量是17。</p>
<p>大于17的任何数字都可以用4和7组合出来。</p>
<p>本题的要求就是在已知两个包装的数量时，求最大不能组合出的数字。</p>
<h3 id="输入格式"><strong>输入格式</strong></h3>
<p>两个正整数 n,mn,m，表示每种包装中糖的颗数。</p>
<h3 id="输出格式"><strong>输出格式</strong></h3>
<p>一个正整数，表示最大不能买到的糖数。</p>
<h3 id="数据范围"><strong>数据范围</strong></h3>
<p>2≤n,m≤10002≤n,m≤1000，<br>
保证数据一定有解。</p>
<h3 id="输入样例"><strong>输入样例：</strong></h3>
<p><code>4 7</code></p>
<h3 id="输出样例"><strong>输出样例：</strong></h3>
<p><code>17</code></p>
<hr>
<p>记录一下暴力的方法</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdbool.h&gt;//用bool类型变量不加头文件acwing编译错误，但devc可以，谨慎起见还是要加上为好

bool dfs(int u,int p,int q)//该函数判断u是能被p和q整除
{
	if(u==0)
	return true;

	if(u&gt;=p&amp;&amp;dfs(u-p,p,q)) return true;//这两行相当于是在全排列用p和q解决u的全部方法，第一时间还是没有想到，琢磨了半天
	if(u&gt;=q&amp;&amp;dfs(u-q,p,q)) return true;

	return false;
}

int main()
{
	int n,m,x;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=1;i&lt;=1000;i++)//默认一个最大值为1000
	{
		if(dfs(i,n,m)==false) x=i;
	}
	printf(&quot;%d&quot;,x);
 } 
</code></pre>
<p>做完这道题感觉暴力还真是混分神技，只不过现在递归用的还是不熟练。</p>
<p>这道题是一道找规律的题，打完表之后数据如下</p>
<pre><code>输入  输出
4 3  5
4 5  11
4 7  17
4 9  23
4 11 29

5 2 3
5 3 7
5 4 11
5 6 19
5 7 23
</code></pre>
<p>总之就是这么个样子，规律就是i=（n-1)*(m-1)-1</p>
<p>一道数论题。。。。最烦的一种题之一。。。。因为数学不好脑子也不灵光总想不到😟</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ACwing1209. 带分数]]></title>
        <id>https://happyeathand.github.io/post/acwing1209-dai-fen-shu/</id>
        <link href="https://happyeathand.github.io/post/acwing1209-dai-fen-shu/">
        </link>
        <updated>2022-03-09T05:04:34.000Z</updated>
        <content type="html"><![CDATA[<p>100100 可以表示为带分数的形式：100=3+69258714100=3+69258714</p>
<p>还可以表示为：100=82+3546197100=82+3546197</p>
<p>注意特征：带分数中，数字 1∼91∼9 分别出现且只出现一次（不包含 00）。</p>
<p>类似这样的带分数，100100 有 1111 种表示法。</p>
<h3 id="输入格式"><strong>输入格式</strong></h3>
<p>一个正整数。</p>
<h3 id="输出格式"><strong>输出格式</strong></h3>
<p>输出输入数字用数码 1∼91∼9 不重复不遗漏地组成带分数表示的全部种数。</p>
<h3 id="数据范围"><strong>数据范围</strong></h3>
<p>1≤N&lt;1061≤N&lt;106</p>
<h3 id="输入样例1"><strong>输入样例1：</strong></h3>
<p><code>100</code></p>
<h3 id="输出样例1"><strong>输出样例1：</strong></h3>
<p><code>11</code></p>
<h3 id="输入样例2"><strong>输入样例2：</strong></h3>
<p><code>105</code></p>
<h3 id="输出样例2"><strong>输出样例2：</strong></h3>
<p><code>6</code></p>
<hr>
<h3 id="先贴题解"><strong>先贴题解</strong></h3>
<pre><code>#include&lt;stdio.h&gt;
int n,ans,o,p,q;
int a[9],state[10];//数组a表示9个数的全排列，state[i]表示数字i是否在a内

int ca(int x,int y)/*这是一个用于计算的函数，把a[x]到a[y]的数字用整型表示出来，最终返回值是计算结果*/
{
	int num=0;
	for(int i=x;i&lt;=y;i++)
	{
		num=num*10+a[i];
	}
	return num;
}

int check(int x,int y,int z)//用于判断是否符合题意的函数
{
	if(y%z==0&amp;&amp;x+y/z==n)
	return 1;
	else
	return 0;
}

void dfs(int x)//x代表已经放了几个数字进去
{
	if(x==9)
	{
		for(int i=0;i&lt;7;i++)//第一段数字
		{
			for(int j=i+1;j&lt;8;j++)//第二段数字
			{
				o=ca(0,i);//第一段数字的值
				p=ca(i+1,j);//第二段数字的值
				q=ca(j+1,8);//第三段数字的值
				if(check(o,p,q)) ans++;//符合题意，结果＋1
			}
			
		}
		return;//这个还是得写一下
	}
	
	for(int i=1;i&lt;=9;i++)//1~9的9个数字
	{
		if(state[i]==0)
		{
			state[i]=1;
			a[x]=i;
			dfs(x+1);
			state[i]=0;
			a[x]=0;
		}
	}
	
}

int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	dfs(0);
	printf(&quot;%d&quot;,ans);
	return 0;
} 
</code></pre>
<p>这种题一般第一眼都毫无思路，看题解都要看好几遍，不过多看几遍之后就大概了解什么意思了。</p>
<p>这道题的大概解法是枚举1~9的所有排列，然后分成三段，分别作为整数分母和分子然后挨个验证一下，符合的话结果就+1。</p>
<p>前边一开始是理解的，只不过递归的全排列又懵了一下，还是for循环里加递归函数的情况，函数出口下面恢复现场就可以了，这点又忘记了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ACwing717. 简单斐波那契]]></title>
        <id>https://happyeathand.github.io/post/acwing717-jian-dan-fei-bo-na-qi/</id>
        <link href="https://happyeathand.github.io/post/acwing717-jian-dan-fei-bo-na-qi/">
        </link>
        <updated>2022-03-06T04:44:57.000Z</updated>
        <content type="html"><![CDATA[<p>以下数列 0 1 1 2 3 5 8 13 21 ... 被称为斐波纳契数列。</p>
<p>这个数列从第 33 项开始，每一项都等于前两项之和。</p>
<p>输入一个整数 NN，请你输出这个序列的前 NN 项。</p>
<h3 id="输入格式"><strong>输入格式</strong></h3>
<p>一个整数 NN。</p>
<h3 id="输出格式"><strong>输出格式</strong></h3>
<p>在一行中输出斐波那契数列的前 NN 项，数字之间用空格隔开。</p>
<h3 id="数据范围"><strong>数据范围</strong></h3>
<p>0&lt;N&lt;460&lt;N&lt;46</p>
<h3 id="输入样例"><strong>输入样例：</strong></h3>
<p><code>5</code></p>
<h3 id="输出样例"><strong>输出样例：</strong></h3>
<p><code>0 1 1 2 3</code></p>
<hr>
<h3 id="递归"><strong>递归</strong></h3>
<pre><code>#include&lt;stdio.h&gt;
int n,a[100];
int dfs(int x)
{
	if(x==1)
	{
		return 0;
	}
	if(x==2||x==3)
	{
		return 1;
	}
	if(a[x]!=0)
	{
		return a[x];
	}
	return dfs(x-1)+dfs(x-2);
}
int main()
{
	int i;
	scanf(&quot;%d&quot;,&amp;n);
	for(i=1;i&lt;=n;i++)
	{
		a[i]=dfs(i);
		printf(&quot;%d &quot;,a[i]);
	}
	return 0;
}
</code></pre>
<p>这道题记录一下主要是这个记忆化的方法，之前用普通的递归可以通过，但是这次测试数据卡在了45，程序在运算的时候有明显的卡顿，显然超时了，解决方法之一就是利用记忆化的方法，每一次计算后把算出来的数存一下就ok了。看起来很简单却没有想到。</p>
<hr>
<h3 id="递推"><strong>递推</strong></h3>
<pre><code>#include&lt;stdio.h&gt;
int a[100];
int main()
{
	int n,i;
	scanf(&quot;%d&quot;,&amp;n);
	a[1]=0;
	a[2]=a[3]=1;
	for(i=1;i&lt;=n;i++)
	{
		if(i&lt;4)
		{
			printf(&quot;%d &quot;,a[i]);
		}
		else
		{
			a[i]=a[i-1]+a[i-2];
			printf(&quot;%d &quot;,a[i]);
		}
	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ACwing93. 递归实现组合型枚举]]></title>
        <id>https://happyeathand.github.io/post/acwing93-di-gui-shi-xian-zu-he-xing-mei-ju/</id>
        <link href="https://happyeathand.github.io/post/acwing93-di-gui-shi-xian-zu-he-xing-mei-ju/">
        </link>
        <updated>2022-03-05T07:06:27.000Z</updated>
        <content type="html"><![CDATA[<p>从 1∼n1∼n 这 nn 个整数中随机选出 mm 个，输出所有可能的选择方案。</p>
<h3 id="输入格式"><strong>输入格式</strong></h3>
<p>两个整数 n,mn,m ,在同一行用空格隔开。</p>
<h3 id="输出格式"><strong>输出格式</strong></h3>
<p>按照从小到大的顺序输出所有方案，每行 11 个。</p>
<p>首先，同一行内的数升序排列，相邻两个数用一个空格隔开。</p>
<p>其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面（例如 1 3 5 7 排在 1 3 6 8 前面）。</p>
<h3 id="数据范围"><strong>数据范围</strong></h3>
<p>n&gt;0n&gt;0 ,<br>
0≤m≤n0≤m≤n ,<br>
n+(n−m)≤25n+(n−m)≤25</p>
<h3 id="输入样例"><strong>输入样例：</strong></h3>
<p><code>5 3</code></p>
<h3 id="输出样例"><strong>输出样例：</strong></h3>
<pre><code>1 2 3 
1 2 4 
1 2 5 
1 3 4 
1 3 5 
1 4 5 
2 3 4 
2 3 5 
2 4 5 
3 4 5 
</code></pre>
<hr>
<h3 id="题解"><strong>题解</strong></h3>
<pre><code>#include&lt;stdio.h&gt;
int m,n,a[100];
void dfs(int x,int y)//x代表该填第x位，y表示从y开始判断
{
	if(x&gt;m)
	{
		for(int i=1;i&lt;=m;i++)
		{
			printf(&quot;%d &quot;,a[i]);
		}
		printf(&quot;\n&quot;);
		return ;//记得return
	}
	
	for(int i=y;i&lt;=n;i++)
	{
		a[x]=i;
		dfs(x+1,i+1);//注意第二空不是y+1，是i+1
		a[x]=0;//恢复现场，回溯
	}
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	dfs(1,1);
	return 0;
}
</code></pre>
<p>在构造函数时，首先是参数的选择出现了问题，dfs（）里的x和y想的没有问题，错在了数组的定义上，应该是受92题的影响，想按照92题的方式求解，在函数里加一些判断和限制条件就可以了，所以数组一开始定义的还是每个数的选取状态，在看了视频后才复刻了一遍算法。</p>
<p>这个算法好在不需要作比较判断大小，按照顺序把数字往数组里放的话顺序肯定是对的，最好直接输出就行了。有一个易错点在于dfs里的第二个for循环dfs（x+1，i+1），第一次写成了y+1。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ACwing92. 递归实现指数型枚举]]></title>
        <id>https://happyeathand.github.io/post/acwing92-di-gui-shi-xian-zhi-shu-xing-mei-ju/</id>
        <link href="https://happyeathand.github.io/post/acwing92-di-gui-shi-xian-zhi-shu-xing-mei-ju/">
        </link>
        <updated>2022-03-05T04:53:52.000Z</updated>
        <content type="html"><![CDATA[<p>从 1∼n1∼n 这 nn 个整数中随机选取任意多个，输出所有可能的选择方案。</p>
<p>输入格式</p>
<p>输入一个整数 nn。</p>
<h3 id="输出格式"><strong>输出格式</strong></h3>
<p>每行输出一种方案。</p>
<p>同一行内的数必须升序排列，相邻两个数用恰好 11 个空格隔开。</p>
<p>对于没有选任何数的方案，输出空行。</p>
<p>本题有自定义校验器（SPJ），各行（不同方案）之间的顺序任意。</p>
<h3 id="数据范围"><strong>数据范围</strong></h3>
<p>1≤n≤151≤n≤15</p>
<h3 id="输入样例"><strong>输入样例：</strong></h3>
<p><code>3</code></p>
<h3 id="输出样例"><strong>输出样例：</strong></h3>
<pre><code>3
2
2 3
1
1 3
1 2
1 2 3
</code></pre>
<hr>
<h3 id="题解"><strong>题解</strong></h3>
<pre><code>#include&lt;stdio.h&gt;
int n,x;
int state[100];
void dfs(int x)
{
	int i;
	if(x&gt;n)
	{
		for(i=1;i&lt;=n;i++)
		{
			if(state[i]==1)
			printf(&quot;%d &quot;,i);
		}
		printf(&quot;\n&quot;);
		return;
	}
	
	state[x]=1;
	dfs(x+1);
	state[x]=0;
	
	state[x]=0;
	dfs(x+1);
	state[x]=0;
}
int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	dfs(1);
}
</code></pre>
<h3 id="思路"><strong>思路：</strong></h3>
<p>对于1~n，按顺序挨个做判断，可以选择选或不选，每做出一次选择后，dfs（x+1），进行下一个位置的选择，直到x&gt;n即判断完毕，得到了一个答案，然后再退出本次递归，上层递归函数继续顺序往下执行，直到最后最外层代码执行完毕，退出。</p>
<p>与94题不同的是，这道题的dfs在输出完毕后需要加一个return，这是因为94题刚好i&gt;n会退出函数，所以一般来讲的话还是要加个return比较好。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ACwing 94.递归实现排列型枚举]]></title>
        <id>https://happyeathand.github.io/post/acwing-94di-gui-shi-xian-pai-lie-xing-mei-ju/</id>
        <link href="https://happyeathand.github.io/post/acwing-94di-gui-shi-xian-pai-lie-xing-mei-ju/">
        </link>
        <updated>2022-03-05T02:41:15.000Z</updated>
        <content type="html"><![CDATA[<p>把 1∼n1∼n 这 nn 个整数排成一行后随机打乱顺序，输出所有可能的次序。</p>
<h3 id="输入格式"><strong>输入格式</strong></h3>
<p>一个整数 nn。</p>
<h3 id="输出格式"><strong>输出格式</strong></h3>
<p>按照从小到大的顺序输出所有方案，每行 11 个。</p>
<p>首先，同一行相邻两个数用一个空格隔开。</p>
<p>其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面。</p>
<p>数据范围</p>
<p>1≤n≤91≤n≤9</p>
<p>输入样例：<br>
<code>3</code><br>
输出样例：</p>
<pre><code>1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
</code></pre>
<hr>
<h3 id="题解"><strong>题解</strong></h3>
<pre><code>#include&lt;stdio.h&gt;

int state[100],a[100];//定义两个数组，state[z]代表z的状态，0为未使用过，1为已经使用过
                      //a[i]代表的是正在排列的数组，i表示的是第i位
int n;
void dfs(int x)//该函数没有返回值，只有输出
{
	if(x&gt;n)//如果正在排列的数组已经满了，开始按顺序输出
	{
		int i;
		for(i=1;i&lt;=n;i++)
		{
			printf(&quot;%d &quot;,a[i]);
		}
		printf(&quot;\n&quot;);
	}
 
//下面是还没有排好a[]的运算
	int i;
	for(i=1;i&lt;=n;i++)
	{
		if(state[i]!=1)
		{
			a[x]=i;
			state[i]=1;
			dfs(x+1);
			
			state[i]=0;//回溯，保证i的状态恢复为未使用过的状态
		}
		
	}
}

int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	dfs(1);//从第一位开始判断填哪个数
}
</code></pre>
<p>题解的思路是按排列的数组的位数，依次放数字，放满之后再依次回溯，选择其他的数字再放置，大体思路比较清晰，唯一难理解的的地方是回溯。</p>
<p>思考后发现是回溯的出口出了问题，最开始想的是回溯后函数会重复，即便回溯了下一次判断还是会填这个数，但是回溯在函数出口的下面一行，而且在for循环里，已经判断过是不会再判断了，这样state[i]可以恢复为0，本身正在处理的dfs还能另填别的数字。   而最后的出口则是一直退退退最后到dfs（1）到n后没的填了，dfs（1）的for循环也执行完了，自己就结束运行了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[洛谷 P1028 [NOIP2001 普及组] 数的计算]]></title>
        <id>https://happyeathand.github.io/post/luo-gu-p1028-noip2001-pu-ji-zu-shu-de-ji-suan/</id>
        <link href="https://happyeathand.github.io/post/luo-gu-p1028-noip2001-pu-ji-zu-shu-de-ji-suan/">
        </link>
        <updated>2022-01-16T10:55:26.000Z</updated>
        <content type="html"><![CDATA[<p>##题目描述<br>
我们要求找出具有下列性质数的个数(包含输入的正整数 nn)。</p>
<p>先输入一个正整数 nn(n \le 1000n≤1000),然后对此正整数按照如下方法进行处理：</p>
<p>1.不作任何处理；</p>
<p>2.在它的左边加上一个正整数,但该正整数不能超过原数的一半；</p>
<p>3.加上数后,继续按此规则进行处理,直到不能再加正整数为止。</p>
<p><strong>输入格式</strong><br>
11 个正整数 nn(n \le 1000n≤1000)</p>
<p><strong>输出格式</strong><br>
11 个整数，表示具有该性质数的个数。<br>
输入输出样例<br>
输入 #1复制</p>
<p>6<br>
输出 #1复制</p>
<p>6<br>
说明/提示<br>
满足条件的数为</p>
<p>6，16，26，126，36，136</p>
<p>【题目来源】</p>
<h2 id="noip-2001-普及组第一题">NOIP 2001 普及组第一题</h2>
<p>##递归<br>
第一反应还是用递归的，但是这个题单貌似用递归的都会超时，限时1s，但是还是要用递归做一下</p>
<p>ps:一开始的递归思路乱了，其实很简单，代码如下</p>
<pre><code>#include&lt;stdio.h&gt;
int pd(int n);//函数的作用为判断整型变量n的解的个数
int pd(int n)
{
	if(n==1)//递归的尽头，1的解只有它本身就是1
	return 1;
	int i,count=0;
	for(i=1;i&lt;=n/2;i++)//这里挨个递归，只要i&lt;=n/2那么就去计算i的解的个数
	{
		count=count+pd(i);
/*一开始写的是count=count+pd(i)+1，因为想把它本身也算进去，但这就犯了递归最常见的错误，参与了递归自己的中间运算，没有从大局的角度出发，避免去想递归的细节，过于拘泥于递归的过程反而会导致结果错误，所以只要想着最后结果+1就好了*/
	}
	return count+1;//就是这里，递归出来的值+1就好了
}
int main()
{
	int x;
	scanf(&quot;%d&quot;,&amp;x);
	x=pd(x);
	printf(&quot;%d&quot;,x);
    return 0;
}
</code></pre>
<p>但是肯定不会这么简单就给过的，时间复杂度太高，一定会超时的，具体不知道但肯定大于1s。</p>
<hr>
<p>递推<br>
看完题解，原来还有递推这么个东西，感觉相反与递归，递推要求把每一个细节都照顾到，总之用递推时间复杂度低了，但是要保证面面俱到，要细心。</p>
<p>而且要先把规律找到，才是最重要的</p>
<p>首先是这个东西</p>
<pre><code>f[1]=1
f[2]=2=f[1]+1
f[3]=2=f[1]+1
f[4]=4=f[1]+f[2]+1
f[5]=4=f[1]+f[2]+1
</code></pre>
<p>算哪个值我只要把它前面的都加起来就好了</p>
<hr>
<p>要注意的是比如说<br>
<code>f[2]=2=f[1]+1</code><br>
很明显这个f[2]已经加上本身了，因为每个数本身也算是一个解，比如说求f[6]，用下面的递推式的话就不用再单独加16，26，36 这三种情况了，因为在他们自己的函数中已经算上它们自己本身了。</p>
<hr>
<p>代码如下</p>
<pre><code>#include&lt;stdio.h&gt;
int main()
{
	int n,i,j;
	scanf(&quot;%d&quot;,&amp;n);
	int a[1001]={0};
	for(i=1;i&lt;=n;i++/*要算f[n]的话，要把n/2以前的f也统统加上，所以要先判断n以前符合条件的f们*/
	{
		for(j=1;j&lt;=i/2;j++)/*这里就是具体的判断过程了，将n以前的数挨个判断*/
		{
			a[i]=a[i]+a[j];
		}
		a[i]++;//最后不要忘了加上自己
	}
	printf(&quot;%d&quot;,a[n]);
    return 0;
}
</code></pre>
<hr>
<p>今天是2022/3/31，看到以前这道题才知道是dp。。。。🤔真是个奇妙的算法</p>
]]></content>
    </entry>
</feed>