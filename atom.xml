<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://happyeathand.github.io</id>
    <title>Night Voyager</title>
    <updated>2022-01-16T11:17:26.765Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://happyeathand.github.io"/>
    <link rel="self" href="https://happyeathand.github.io/atom.xml"/>
    <subtitle> 切忌好高骛远</subtitle>
    <logo>https://happyeathand.github.io/images/avatar.png</logo>
    <icon>https://happyeathand.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Night Voyager</rights>
    <entry>
        <title type="html"><![CDATA[洛谷 P1028 [NOIP2001 普及组] 数的计算]]></title>
        <id>https://happyeathand.github.io/post/luo-gu-p1028-noip2001-pu-ji-zu-shu-de-ji-suan/</id>
        <link href="https://happyeathand.github.io/post/luo-gu-p1028-noip2001-pu-ji-zu-shu-de-ji-suan/">
        </link>
        <updated>2022-01-16T10:55:26.000Z</updated>
        <content type="html"><![CDATA[<p>##题目描述<br>
我们要求找出具有下列性质数的个数(包含输入的正整数 nn)。</p>
<p>先输入一个正整数 nn(n \le 1000n≤1000),然后对此正整数按照如下方法进行处理：</p>
<p>1.不作任何处理；</p>
<p>2.在它的左边加上一个正整数,但该正整数不能超过原数的一半；</p>
<p>3.加上数后,继续按此规则进行处理,直到不能再加正整数为止。</p>
<p><strong>输入格式</strong><br>
11 个正整数 nn(n \le 1000n≤1000)</p>
<p><strong>输出格式</strong><br>
11 个整数，表示具有该性质数的个数。<br>
输入输出样例<br>
输入 #1复制</p>
<p>6<br>
输出 #1复制</p>
<p>6<br>
说明/提示<br>
满足条件的数为</p>
<p>6，16，26，126，36，136</p>
<p>【题目来源】</p>
<h2 id="noip-2001-普及组第一题">NOIP 2001 普及组第一题</h2>
<p>##递归<br>
第一反应还是用递归的，但是这个题单貌似用递归的都会超时，限时1s，但是还是要用递归做一下</p>
<p>ps:一开始的递归思路乱了，其实很简单，代码如下</p>
<pre><code>#include&lt;stdio.h&gt;
int pd(int n);//函数的作用为判断整型变量n的解的个数
int pd(int n)
{
	if(n==1)//递归的尽头，1的解只有它本身就是1
	return 1;
	int i,count=0;
	for(i=1;i&lt;=n/2;i++)//这里挨个递归，只要i&lt;=n/2那么就去计算i的解的个数
	{
		count=count+pd(i);
/*一开始写的是count=count+pd(i)+1，因为想把它本身也算进去，但这就犯了递归最常见的错误，参与了递归自己的中间运算，没有从大局的角度出发，避免去想递归的细节，过于拘泥于递归的过程反而会导致结果错误，所以只要想着最后结果+1就好了*/
	}
	return count+1;//就是这里，递归出来的值+1就好了
}
int main()
{
	int x;
	scanf(&quot;%d&quot;,&amp;x);
	x=pd(x);
	printf(&quot;%d&quot;,x);
    return 0;
}
</code></pre>
<h2 id="但是肯定不会这么简单就给过的时间复杂度太高一定会超时的具体不知道但肯定大于1s">但是肯定不会这么简单就给过的，时间复杂度太高，一定会超时的，具体不知道但肯定大于1s。</h2>
<p>##递推<br>
看完题解，原来还有递推这么个东西，感觉相反与递归，递推要求把每一个细节都照顾到，总之用递推时间复杂度低了，但是要保证面面俱到，要细心。</p>
<p>而且要先把规律找到，才是最重要的</p>
<p>首先是这个东西</p>
<pre><code>f[1]=1
f[2]=2=f[1]+1
f[3]=2=f[1]+1
f[4]=4=f[1]+f[2]+1
f[5]=4=f[1]+f[2]+1
</code></pre>
<h2 id="算哪个值我只要把它前面的都加起来就好了">算哪个值我只要把它前面的都加起来就好了</h2>
<h2 id="要注意的是比如说f22f11很明显这个f2已经加上本身了因为每个数本身也算是一个解比如说求f6用下面的递推式的话就不用再单独加162636-这三种情况了因为在他们自己的函数中已经算上它们自己本身了">要注意的是比如说<br>
<code>f[2]=2=f[1]+1</code><br>
很明显这个f[2]已经加上本身了，因为每个数本身也算是一个解，比如说求f[6]，用下面的递推式的话就不用再单独加16，26，36 这三种情况了，因为在他们自己的函数中已经算上它们自己本身了。</h2>
<p>代码如下</p>
<pre><code>#include&lt;stdio.h&gt;
int main()
{
	int n,i,j;
	scanf(&quot;%d&quot;,&amp;n);
	int a[1001]={0};
	for(i=1;i&lt;=n;i++/*要算f[n]的话，要把n/2以前的f也统统加上，所以要先判断n以前符合条件的f们*/
	{
		for(j=1;j&lt;=i/2;j++)/*这里就是具体的判断过程了，将n以前的数挨个判断*/
		{
			a[i]=a[i]+a[j];
		}
		a[i]++;//最后不要忘了加上自己
	}
	printf(&quot;%d&quot;,a[n]);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[建站历史及更新😃]]></title>
        <id>https://happyeathand.github.io/post/jian-zhan-li-shi-ji-geng-xin/</id>
        <link href="https://happyeathand.github.io/post/jian-zhan-li-shi-ji-geng-xin/">
        </link>
        <updated>2021-11-11T10:56:11.000Z</updated>
        <content type="html"><![CDATA[<p>2021.11.7  第一次成功远程连接，域名为happyeathand.github.io<br>
2021.11.11  更换访问域名为 chishoushou.top<br>
2021.11.12  欢迎看板娘入驻！！！🎉🎉🎉😋</p>
]]></content>
    </entry>
</feed>